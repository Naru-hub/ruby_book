# 配列[位置,取得する長さ]
# ２つ目の要素から3つ分の要素を取得する
a = [1,2,3,4,5]
a[1,3]

# values_atメソッド取得したい要素の添字を複数指定する
a = [1,2,3,4,5]
a.values_at(0,2,4)

# 「配列の長さ-1」すると最後の要素取得
a = [1,2,3]
a[a.size - 1]

a = [1,2,3]
# 最後の要素を取得する
[-1]

# 最後から２番目の要素を取得する
a[-2]

# 最後から２番目の要素から2つの要素を取得する
a[-2, 2]

# 配列lastメソッド 配列の最後の要素を取得できる（引数に0以上の数値を渡すと最後のn個の要素を取得）
a = [1,2,3]
a.last
a.last(2)

# firstメソッド 先頭の要素を取得
a = [1,2,3]
a.first
a.first(2)

# 開始位置と長さを指定して要素を置き換える
a = [1,2,3,4,5]
# 2つ目から3要素分を100で置き換える
a[1,3] = 100
a             #[1 100 5]

# pushメソッド 複数の値を追加できる
a = []
a.push(1)
a.push(2,3)

# deleteメソッド 指定した値に一致する要素を削除したい場合
a = [1,2,3,1,2,3]
# 値が2である要素を削除する(削除した値が戻り値になる)
a.delete(2)
a
# 存在しない値を指定するとnilが返る
a.delete(5)  #nil
a   #[1,3,1,3]


# concatメソッド 配列を連結する。元の配列（メソッドを呼び出した側の配列）が変更される
a = [1]
b = [2,3]
a.concat(b)  #[1,2,3]

# aは変更される(破壊的)
a  #[1,2,3]

# bは変更されない
b  #[2,3]

# +を使うと元の配列を変更せず新しい配列を作成する(通常はこちらを利用)
a = [1]
b = [2,3]
a + b  #[1,2,3]

# aもbも破壊されない
a  #[1]
b  #[2,3]

# |は和集合を求める演算子で2つの配列の要素をすべて集め重複しないようにして返す(元の配列は変更しない、非破壊的)
a = [1,2,3]
b = [3,4,5]
a | b  #[1,2,3,4,5]

# -は差集合を求める演算子で左の配列から右の配列に含まれる要素を取り除く(元の配列は変更しない、非破壊的)
a = [1,2,3]
b = [3,4,5]
a - b  #[1,2]

# &は積集合を求める演算子で2つの配列に共通する要素を返します(元の配列は変更しない、非破壊的)
a = [1,2,3]
b = [3,4,5]
a & b    #[3]

# Setクラス 配列よりも効率的に集合を扱える(本格的な集合演算をする場合はこっちを使う)
require 'set'

a = Set.new([1,2,3])
b = Set.new([3,4,5])
puts a | b  #<Set: {1,2,3,4,5}>
puts a - b  #<Set: {1,2}>
puts a & b  #<Set: {3}>

# 多重代入では左辺の変数より右辺の個数が多い場合はみ出した値が切り捨てられるが
e,f = 100,200,300
puts e
puts f
# 左辺の変数に*をつけると残りの全要素を配列として受け取る事ができる
e,*f = 100,200,300
puts e
puts f

# メソッドの引数に「１つ配列」ではなく配列を展開して「複数の引数」として渡したい場合、配列の前に*を置きます(splat展開)
a = []
b = [2,3]
a.push(1)
# 配列を*付きで追加する
a.push(*b)  #[1,2,3]


# 個数制限のない引数のことを可変長引数といい、メソッドで可変長引数を使いたい場合引数名の手前に*をつけます
def greeting(*names)
  "#{names.join('と')}、こんにちは！"
end

puts greeting('田中さん')                                      #田中さん、こんにちは！
puts greeting('田中さん','鈴木さん')                           #田中さんと鈴木さん、こんにちは！
puts greeting('田中さん','鈴木さん','佐藤さん')                #田中さんと鈴木さんと佐藤さん、こんにちは！